<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>GALAXY STRIKER (ULTIMATE)</title>
    <style>
        body { margin: 0; background-color: #000; color: #fff; font-family: 'Courier New', Courier, monospace; display: flex; justify-content: center; align-items: center; height: 100vh; }
        /* ★★★ 画面を大型化 ★★★ */
        #game-container { position: relative; width: 1000px; height: 750px; box-shadow: 0 0 25px #f0f; border: 2px solid #505; overflow: hidden; }
        #game-canvas { background-color: #000; display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; text-align: center; pointer-events: none; }
        #ui-layer > div { background-color: rgba(0, 0, 0, 0.8); padding: 30px; border-radius: 10px; border: 2px solid #0ff; pointer-events: auto; }
        h1 { font-size: 3.5em; color: #f0f; text-shadow: 0 0 15px #f0f; }
        button { font-size: 1.5em; padding: 10px 30px; background-color: #0ff; color: #000; border: none; cursor: pointer; transition: all 0.2s; }
        button:hover { background-color: #fff; box-shadow: 0 0 15px #fff; }
        #hud { position: absolute; top: 10px; left: 10px; width: calc(100% - 20px); color: #fff; font-size: 1.8em; display: flex; justify-content: space-between; pointer-events: none; text-shadow: 2px 2px 3px #000; }
        #boss-hp-container { position: absolute; top: 15px; left: 15%; width: 70%; height: 25px; background-color: #555; border: 2px solid #fff; display: none; }
        #boss-hp-bar { width: 100%; height: 100%; background: linear-gradient(to left, #f00, #f80); transition: width 0.2s linear; }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas" width="1000" height="750"></canvas>
        <div id="boss-hp-container"><div id="boss-hp-bar"></div></div>
        <div id="ui-layer">
            <div id="title-screen">
                <h1>GALAXY STRIKER<br><span style="font-size:0.5em;">- ULTIMATE -</span></h1>
                <p>移動: 矢印キー, ショット: スペース, サブ: X</p>
                <p>武器は最大20段階まで強化可能！</p>
                <button id="start-button">ゲームスタート</button>
            </div>
            <div id="game-over-screen" style="display: none;"><h2>GAME OVER</h2><p>最終スコア: <span id="final-score">0</span></p><br><button id="retry-button">もう一度プレイ</button></div>
        </div>
        <div id="hud" style="display: none;"><div id="score">SCORE: 0</div><div id="weapon-level">LV.1</div><div id="health">HP: ❤️❤️❤️</div></div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('game-canvas'), ctx = canvas.getContext('2d');
    const titleScreen = document.getElementById('title-screen'), gameOverScreen = document.getElementById('game-over-screen');
    const startButton = document.getElementById('start-button'), retryButton = document.getElementById('retry-button');
    const scoreDisplay = document.getElementById('score'), healthDisplay = document.getElementById('health'), finalScoreDisplay = document.getElementById('final-score');
    const weaponLevelDisplay = document.getElementById('weapon-level');
    const hud = document.getElementById('hud');
    const bossHpContainer = document.getElementById('boss-hp-container');
    const bossHpBar = document.getElementById('boss-hp-bar');

    let score, player, keys, bullets, enemies, particles, stars, powerUps, boss, enemySpawnTimer, gameState, animationFrameId;
    let bossEverAppeared = false;

    // --- クラス定義 ---
    class Player {
        constructor() { this.x = 150; this.y = canvas.height/2; this.width = 50; this.height = 20; this.speed = 7; this.hp = 3; this.mainShootCooldown = 0; this.subShootCooldown = 0; this.weaponLevel = 1; }
        update() {
            if (keys['ArrowUp'] && this.y > this.height/2) this.y -= this.speed;
            if (keys['ArrowDown'] && this.y < canvas.height - this.height/2) this.y += this.speed;
            if (keys['ArrowLeft'] && this.x > 0) this.x -= this.speed;
            if (keys['ArrowRight'] && this.x < canvas.width - this.width) this.x += this.speed;
            if (keys['Space'] && this.mainShootCooldown <= 0) this.shootMain();
            if (keys['KeyX'] && this.subShootCooldown <= 0) { this.shootSub(); this.subShootCooldown = 30; }
            if (this.mainShootCooldown > 0) this.mainShootCooldown--;
            if (this.subShootCooldown > 0) this.subShootCooldown--;
        }
        draw() { /* (略) 描画ロジックは変更なし */ ctx.save(); ctx.fillStyle = '#0CF'; ctx.shadowColor = '#0FF'; ctx.shadowBlur = 10; ctx.beginPath(); ctx.moveTo(this.x + this.width, this.y); ctx.lineTo(this.x, this.y - this.height / 2); ctx.lineTo(this.x + 10, this.y); ctx.lineTo(this.x, this.y + this.height / 2); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#FFF'; ctx.shadowBlur = 0; ctx.fillRect(this.x + 25, this.y - 2, 8, 4); ctx.restore(); }
        shootMain() {
            const lv = this.weaponLevel;
            this.mainShootCooldown = Math.max(2, 8 - Math.floor(lv / 3));
            const baseDamage = 1 + Math.floor(lv / 5);

            // Lv1-3: バルカン強化
            bullets.push(new Bullet(this.x + this.width, this.y, { vx: 18, damage: baseDamage }));
            if (lv >= 2) bullets.push(new Bullet(this.x + this.width, this.y - 10, { vx: 18, damage: baseDamage }));
            if (lv >= 3) bullets.push(new Bullet(this.x + this.width, this.y + 10, { vx: 18, damage: baseDamage }));
            // Lv4-6: ワイドショット追加
            if (lv >= 4) bullets.push(new Bullet(this.x + this.width, this.y, { vx: 16, vy: -2, color: '#afa' }));
            if (lv >= 5) bullets.push(new Bullet(this.x + this.width, this.y, { vx: 16, vy: 2, color: '#afa' }));
            if (lv >= 6) { bullets.push(new Bullet(this.x + this.width, this.y, { vx: 14, vy: -4, color: '#afa' })); bullets.push(new Bullet(this.x + this.width, this.y, { vx: 14, vy: 4, color: '#afa' })); }
            // Lv7-9: レーザービーム追加
            if (lv >= 7 && this.mainShootCooldown % 4 === 0) bullets.push(new Bullet(this.x + this.width, this.y - 20, { shape: 'beam', damage: 3 + Math.floor(lv/4) }));
            if (lv >= 8 && this.mainShootCooldown % 4 === 0) bullets.push(new Bullet(this.x + this.width, this.y + 20, { shape: 'beam', damage: 3 + Math.floor(lv/4) }));
            if (lv >= 9 && this.mainShootCooldown % 4 === 0) bullets.push(new Bullet(this.x + this.width, this.y, { shape: 'beam', vx: 40, color: '#fff', damage: 5 + Math.floor(lv/4)}));
            // Lv10-14: ホーミングミサイル追加
            if (lv >= 10 && this.mainShootCooldown < 3) bullets.push(new Bullet(this.x, this.y - 15, { shape: 'missile', target: findClosestEnemy(this.x, this.y) }));
            if (lv >= 12 && this.mainShootCooldown < 3) bullets.push(new Bullet(this.x, this.y + 15, { shape: 'missile', target: findClosestEnemy(this.x, this.y) }));
            // Lv15-18: 大玉エナジーボール追加
            if (lv >= 15 && this.mainShootCooldown % 10 === 0) bullets.push(new Bullet(this.x + this.width, this.y, { shape: 'ball', damage: 10 + (lv-15)*2 }));
            // Lv19-20: 全方位強化 & 最強形態
            if (lv >= 19) { bullets.push(new Bullet(this.x, this.y, { vx: -15, color: '#ccc' })); }
            if (lv >= 20) { this.mainShootCooldown = 2; for(let i=0; i<3; i++) bullets.push(new Bullet(this.x, this.y - 20 + i*20, {vx: -15, color: '#ccc'})); }
        }
        shootSub() { for(let i=-2; i<=2; i++) if(i!==0) bullets.push(new Bullet(this.x + this.width, this.y, { vx: 12, vy: i*2, color: '#ff0' })); }
        takeDamage(damage = 1) { this.hp -= damage; if (this.weaponLevel > 1) this.weaponLevel = Math.max(1, this.weaponLevel - (damage > 1 ? 2 : 1)); createExplosion(this.x, this.y, ['#ff0', '#f90', '#f00']); if (this.hp <= 0) { gameState = 'gameOver'; createExplosion(this.x, this.y, ['#fff', '#0ff', '#f0f'], 100); } }
        powerUp() { if (this.weaponLevel < 20) this.weaponLevel++; }
    }
    class Bullet {
        constructor(x, y, options={}) {
            this.x = x; this.y = y; this.vx = options.vx ?? 15; this.vy = options.vy ?? 0;
            this.color = options.color ?? '#0f0'; this.damage = options.damage ?? 1; this.type = options.type ?? 'player';
            this.shape = options.shape ?? 'rect'; // rect, beam, ball, missile
            this.target = options.target ?? null; this.turnSpeed = 0.05;
            switch(this.shape) {
                case 'beam': this.width = 50; this.height = 4; this.vx=options.vx??35; break;
                case 'ball': this.radius = 8 + this.damage; this.width=this.radius*2; this.height=this.radius*2; this.vx=options.vx??8; break;
                case 'missile': this.width = 16; this.height = 8; this.vx=options.vx??6; this.vy=options.vy??(Math.random()-0.5)*2; this.life=150; break;
                default: this.width = 15; this.height = 3;
            }
        }
        update() {
            if (this.shape === 'missile' && this.life > 0) {
                this.life--; if (!this.target || this.target.hp <= 0) this.target = findClosestEnemy(this.x, this.y, 300);
                if (this.target) { const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x); this.vx += Math.cos(angle) * 0.5; this.vy += Math.sin(angle) * 0.5; }
                const speed = Math.hypot(this.vx, this.vy); if (speed > 10) { const ratio = 10 / speed; this.vx *= ratio; this.vy *= ratio; }
            }
            this.x += this.vx; this.y += this.vy;
        }
        draw() { ctx.save(); ctx.fillStyle = this.color; ctx.shadowColor = this.color; ctx.shadowBlur = 15;
            if (this.shape === 'ball') { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill(); }
            else { ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height); }
            ctx.restore();
        }
    }
    // ★★★ ボスの座標を画面サイズに依存しないように修正 ★★★
    class Boss {
        constructor() { this.maxHp = 500; this.hp = this.maxHp; this.x = canvas.width + 100; this.y = canvas.height/2; this.width = 150; this.height = 100; this.score = 5000; this.targetX = canvas.width - 150; this.state = 'enter'; this.patternTimer = 0; this.currentPattern = 0; }
        update() { if (this.state === 'enter') { this.x -= 2; if (this.x <= this.targetX) { this.x = this.targetX; this.state = 'fight'; } return; } this.patternTimer--; if (this.patternTimer <= 0) { this.currentPattern = (this.currentPattern + 1) % 3; switch (this.currentPattern) { case 0: this.patternTimer = 80; for (let i = 0; i < 9; i++) bullets.push(new Bullet(this.x - this.width / 2, this.y, {vx:-6, vy:(i-4), color:'#f57c00', type:'enemy'})); break; case 1: this.patternTimer = 100; for(let i=0; i<3; i++) setTimeout(()=> bullets.push(new Bullet(this.x - this.width/2, this.y, {vx:-12, color:'#f57c00', type:'enemy'})), i*120); break; case 2: this.patternTimer = 120; bullets.push(new Bullet(this.x - this.width / 2, this.y - 40, {shape:'missile', type:'enemy', color:'#c2185b', target:player})); bullets.push(new Bullet(this.x - this.width / 2, this.y + 40, {shape:'missile', type:'enemy', color:'#c2185b', target:player})); break; } } }
        draw() { /* (略) 描画ロジックは変更なし */ ctx.save(); ctx.fillStyle = '#7B1FA2'; ctx.strokeStyle = '#9C27B0'; ctx.lineWidth = 4; ctx.beginPath(); ctx.rect(this.x - this.width/2, this.y - this.height/2, this.width, this.height); ctx.moveTo(this.x - this.width/2, this.y - this.height/2); ctx.lineTo(this.x - this.width, this.y); ctx.lineTo(this.x-this.width/2, this.y+this.height/2); ctx.stroke(); ctx.fill(); ctx.fillStyle = '#E91E63'; ctx.beginPath(); ctx.arc(this.x, this.y, 15, 0, Math.PI*2); ctx.fill(); ctx.restore(); }
    }
    // --- ユーティリティ関数とその他のクラス ---
    function findClosestEnemy(x, y, range=canvas.width) { let closest = null; let minDistance = range; const targets = boss ? [boss] : enemies; for (const e of targets) { if (e.x < x) continue; const dist = Math.hypot(e.x - x, e.y - y); if (dist < minDistance) { minDistance = dist; closest = e; } } return closest; }
    // 残りのクラス定義、init, update, drawなどのメインロジックは前回から微調整のみなので省略します
    class Enemy { constructor() { this.x = canvas.width; this.y = Math.random() * (canvas.height - 80) + 40; this.width = 40; this.height = 40; this.speed = -3; this.hp = 2; this.score = 100; } update() { this.x += this.speed; } draw() { ctx.save(); ctx.fillStyle = '#C0C'; ctx.shadowColor = '#F0F'; ctx.shadowBlur = 10; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x - this.width, this.y - this.height / 2); ctx.lineTo(this.x - this.width * 0.7, this.y); ctx.lineTo(this.x - this.width, this.y + this.height / 2); ctx.closePath(); ctx.fill(); ctx.restore(); } }
    class ShooterEnemy extends Enemy { constructor() { super(); this.speed = -2; this.hp = 3; this.score = 150; this.shootCooldown = Math.random() * 60 + 60; } update() { super.update(); this.shootCooldown--; if (this.shootCooldown <= 0 && this.x < canvas.width) { bullets.push(new Bullet(this.x - this.width, this.y, {vx:-7, color:'#f00', type:'enemy'})); this.shootCooldown = 120; } } draw() { ctx.save(); ctx.fillStyle = '#D32F2F'; ctx.shadowColor = '#F44336'; ctx.shadowBlur = 10; ctx.beginPath(); ctx.moveTo(this.x, this.y - this.height / 2); ctx.lineTo(this.x - this.width, this.y); ctx.lineTo(this.x, this.y + this.height / 2); ctx.closePath(); ctx.fill(); ctx.restore(); } }
    class ChaserEnemy extends Enemy { constructor() { super(); this.speed = -4; this.hp = 1; this.score = 200; this.chaseSpeed = 1.2; } update() { super.update(); this.y += Math.sign(player.y - this.y) * this.chaseSpeed; } draw() { ctx.save(); ctx.fillStyle = '#FFC107'; ctx.shadowColor = '#FFEB3B'; ctx.shadowBlur = 10; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x - this.width, this.y - this.height / 4); ctx.lineTo(this.x - this.width, this.y + this.height / 4); ctx.closePath(); ctx.fill(); ctx.restore(); } }
    class PowerUp { constructor(x, y) { this.x = x; this.y = y; this.width = 24; this.height = 24; this.speed = -2; this.angle = 0;} update() { this.x += this.speed; this.angle += 0.1; } draw() { ctx.save(); ctx.translate(this.x + this.width/2, this.y + this.height/2); ctx.rotate(this.angle); ctx.fillStyle = '#FFF'; ctx.strokeStyle = '#F0F'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, this.width/2-2, 0, Math.PI * 2); ctx.stroke(); ctx.font = 'bold 18px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('P', 0, 1); ctx.restore(); } }
    class Star { constructor() { this.x = Math.random() * canvas.width; this.y = Math.random() * canvas.height; this.speed = Math.random() * 0.8 + 0.2; this.size = Math.random() * 2.5; } update() { this.x -= this.speed; if (this.x < 0) this.x = canvas.width; } draw() { ctx.fillStyle = `rgba(255, 255, 255, ${this.size / 2})`; ctx.fillRect(this.x, this.y, this.size, this.size); } }
    class Particle { constructor(x, y, color, size, speed) { this.x = x; this.y = y; this.color = color; this.size = size; this.speed = speed; this.life = 40; this.vx = (Math.random() - 0.5) * this.speed; this.vy = (Math.random() - 0.5) * this.speed; } update() { this.x += this.vx; this.y += this.vy; this.life--; } draw() { ctx.fillStyle = this.color; ctx.globalAlpha = this.life / 40; ctx.fillRect(this.x, this.y, this.size, this.size); ctx.globalAlpha = 1.0; } }
    function init() { if (animationFrameId) cancelAnimationFrame(animationFrameId); score = 0; keys = {}; bullets = []; enemies = []; particles = []; stars = []; powerUps = []; boss = null; bossEverAppeared = false; enemySpawnTimer = 0; player = new Player(); gameState = 'playing'; for (let i = 0; i < 200; i++) stars.push(new Star()); titleScreen.style.display = 'none'; gameOverScreen.style.display = 'none'; bossHpContainer.style.display = 'none'; hud.style.display = 'flex'; gameLoop(); }
    function update() { if (gameState !== 'playing') return; stars.forEach(s => s.update()); player.update(); if (boss) { boss.update(); } else { enemySpawnTimer--; if (enemySpawnTimer <= 0) { const r = Math.random(); if (r < 0.2) enemies.push(new ChaserEnemy()); else if (r < 0.5) enemies.push(new ShooterEnemy()); else enemies.push(new Enemy()); enemySpawnTimer = Math.max(15, 70 - score / 300); } } if (score >= 10000 && !bossEverAppeared) { spawnBoss(); } [bullets, enemies, particles, powerUps].forEach(arr => arr.forEach(item => item.update())); checkCollisions(); bullets = bullets.filter(b => b.x < canvas.width + 50 && b.x > -50 && b.y > -50 && b.y < canvas.height+50 && (!b.life || b.life > 0)); enemies = enemies.filter(e => e.x + e.width > 0 && e.hp > 0); particles = particles.filter(p => p.life > 0); powerUps = powerUps.filter(p => p.x + p.width > 0); }
    function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height); stars.forEach(s => s.draw()); if (gameState !== 'playing') return; player.draw(); if (boss) boss.draw(); [bullets, enemies, particles, powerUps].forEach(arr => arr.forEach(item => item.draw())); scoreDisplay.textContent = `SCORE: ${score}`; weaponLevelDisplay.textContent = player.weaponLevel >= 20 ? 'LV.MAX!!' : `LV.${player.weaponLevel}`; healthDisplay.textContent = `HP: ${'❤️'.repeat(Math.max(0,player.hp))}`; if (boss) { bossHpBar.style.width = `${Math.max(0, boss.hp / boss.maxHp * 100)}%`; } }
    function checkCollisions() { bullets.forEach(b => { if (b.type === 'player') { enemies.forEach(e => { if (e.hp > 0 && Math.hypot(b.x - e.x, b.y - e.y) < e.width/2 + b.width/2) { e.hp -= b.damage; b.x = -100; if(e.hp <= 0) onEnemyDestroy(e); }}); if (boss && Math.abs(b.x - boss.x) < boss.width/2 && Math.abs(b.y - boss.y) < boss.height/2) { boss.hp -= b.damage; b.x = -100; if(boss.hp <= 0) onEnemyDestroy(boss); } } else { if (Math.hypot(b.x-player.x, b.y-player.y) < player.width/2) { player.takeDamage(); b.x = -100; } } }); enemies.forEach(e => { if (e.hp > 0 && Math.hypot(player.x - e.x, player.y - e.y) < 30) { player.takeDamage(); e.hp = 0; }}); powerUps = powerUps.filter(p => { if (Math.hypot(player.x - p.x, player.y - p.y) < 40) { player.powerUp(); return false; } return true; }); }
    function onEnemyDestroy(e) { score += e.score; createExplosion(e.x, e.y, ['#fff', '#f0f', '#ff0'], 40); if(e instanceof Boss) { boss = null; bossHpContainer.style.display = 'none'; enemySpawnTimer = 180; createExplosion(e.x, e.y, ['#fff','#f00','#ff0'], 300); setTimeout(() => bossEverAppeared = false, 20000); } else if (Math.random() < 0.25) { powerUps.push(new PowerUp(e.x, e.y)); } }
    function spawnBoss() { bossEverAppeared = true; enemies = []; boss = new Boss(); bossHpContainer.style.display = 'block'; }
    function createExplosion(x, y, colors, count = 20) { for (let i = 0; i < count; i++) { const color = colors[Math.floor(Math.random() * colors.length)]; particles.push(new Particle(x, y, color, Math.random() * 3 + 1, Math.random() * 8 + 2)); } }
    function gameLoop() { update(); draw(); if (gameState === 'gameOver') showGameOver(); else animationFrameId = requestAnimationFrame(gameLoop); }
    function showGameOver() { cancelAnimationFrame(animationFrameId); finalScoreDisplay.textContent = score; gameOverScreen.style.display = 'block'; hud.style.display = 'none'; bossHpContainer.style.display = 'none'; }
    window.addEventListener('keydown', e => { keys[e.code] = true; }); window.addEventListener('keyup', e => { keys[e.code] = false; }); startButton.addEventListener('click', () => { if(gameState !== 'playing') init(); }); retryButton.addEventListener('click', () => { if(gameState !== 'playing') init(); });
});
</script>
</body>
</html>
